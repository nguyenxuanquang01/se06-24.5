# Hợp đồng thông minh

### Hợp đồng thông minh là gì ?

Smart Contract (Hợp Đồng Thông Minh) là một thuật ngữ mô tả một bộ giao thức đặc biệt có khả năng tự động thực hiện các điều khoản, các thoả thuận giữa các bên trong hợp đồng (ở trường hợp này là các hệ thống máy tính) nhờ sự hỗ trợ của công nghệ Blockchain.

Toàn bộ hoạt động của Smart Contract được thực hiện một cách tự động và không có sự can thiệp từ bên ngoài, hay thông qua một bên thứ ba trung gian. Những giao dịch được thực hiện bằng các hợp đồng thông minh rất minh bạch, có thể dễ dàng truy xuất được và không thể bị can thiệp hoặc đảo chiều. Các điều khoản trong Smart Contract tương đương với một hợp đồng có pháp lý và được ghi lại dưới ngôn ngữ của lập trình.

### Hợp đồng hoạt động như thế nào ?

Hợp đồng thông minh hoạt động như một chương trình tất định. Nó thực thi một tác vụ cụ thể trong trường hợp thỏa mãn các điều kiện nhất định. Do đó hợp đồng thông minh tuân theo các câu lệnh "nếu... thì...". Trên mạng Ethereum, hợp đồng thông minh chịu trách nhiệm thực thi và quả lí các hoạt động diễn ra trên blockchain. Về cơ bản, hợp đồng thông minh Ethereum bao gồm một mã hợp đồng và hai khóa công khai. Khóa công khai thứ nhất là khóa do người tạo hợp đồng cung cấp. Khóa còn lại đại diện cho chính hợp đồng, khóa này có vài trò như một mã định danh kỹ thuật số duy nhất cho mỗi hợp đồng thông minh.

### Ví dụ về hợp đồng thông minh

Giả dụ bạn muốn thuê một căn hộ từ tôi. Bạn có thể trả tiền thuê nhà bằng tiền điện tử qua Blockchain. Sau đó biên nhận sẽ được đưa vào một bản hợp đồng thông minh của chúng tôi; Tôi sẽ đưa bạn mật mã vào căn hộ vào một ngày nhất định. Nếu mật mã đó không đến đúng thời hạn giữa 2 bên thống nhất, hợp đồng thông minh sẽ trả lại tiền. Nếu nó đến trước hạn, hệ thống sẽ giữ lại cả tiền và mật mã cho đến kì hạn. Hệ thống hoạt động dựa trên mệnh đề “If – Then” và được giám sát bởi hàng trăm người, vì vậy sẽ không thể có lỗi sai xảy ra trong việc giao nhận.

### Lợi ích của Smart Contract

- **Tự do** : Không bị một cơ quan nào quả lí
- **Phân tán** : Hợp đồng thông minh được sao chép và phân phối trong tất cả các nút của mạng Ethereum. Đây là một điểm khác biệt so với các giải pháp khác dựa trên các máy chủ tập trung.
- **Tất định** : Hợp đồng thông minh chỉ thực hiện các hành động mà chúng được thiết kế để thực hiện trong trường hợp các điều kiện được thỏa mãn. Bên cạnh đó, các kết quả của hợp đồng thông minh không đổi dù người thực hiện là ai.
- **Tự động** : Hợp đồng thông minh có thể tự động hóa tất cả các loại tác vụ, nó hoạt động như một chương trình tự thực hiện. Tuy nhiên, trong hầu hết các trường hợp, nếu hợp đồng thông minh không được kích hoạt, nó sẽ duy trì trạng thái “không hoạt động” và sẽ không thực hiện bất kỳ hành động nào.
- **Không thể thay đổi** : Không thể sửa đổi hợp đồng thông minh sau khi triển khai. Chỉ có thể “xóa” chúng nếu chức năng này đã được thêm vào từ trước. Do đó, có thể nói rằng hợp đồng thông minh giống như một mã chống giả mạo.
- **Có thể tùy chỉnh** : Trước khi triển khai, hợp đồng thông minh có thể được mã hóa theo nhiều cách khác nhau. Vì vậy, chúng có thể được sử dụng để tạo ra nhiều loại ứng dụng phi tập trung (Dapp). Điều này là bởi Ethereum là một blockchain có thể được sử dụng để giải quyết bất kỳ vấn đề tính toán nào (Turing complete).
- **Không cần dựa trên sự tin cậy** : Hai hoặc nhiều bên của hợp đồng có thể tương tác thông qua hợp đồng thông minh mà không cần biết hoặc tin tưởng lẫn nhau. Ngoài ra, công nghệ blockchain đảm bảo tính chính xác của dữ liệu.
- **Minh bạch** : Vì các hợp đồng thông minh dựa trên một blockchain công khai, không ai có thể thay đổi mã nguồn của chúng, mặc dù bất kỳ ai cũng có thể xem được.

### Nhược điểm của Smart Contract

- **Tính pháp** : Bạn sẽ không được bảo vệ quyền lợi khi xảy ra lỗi phát sinh do pháp luật các nước hiện nay chưa có chính sách để khai thác, quản lý smart contract.
- **Chi phí triển khai** : Cần chi trả cho hệ thống cơ sở hạ tầng, máy tính, và các lập trình viên giỏi để họ triển khai.
- **Rủ ro từ Internet** : Bản chất của Smart Contract là rất an toàn, nhưng nếu bạn để lộ một số thông tin nhạy cảm hoặc bị các hacker khai thác các thông tin đó thì chắc chắn sẽ gặp những trường hợp rắc rối.

### Để tạo lên một Smart Contract cần những gì ?

- **Chủ thể hợp đồng** : Smart Contract phải được cấp khả năng truy cập đến sản phẩm/dịch vụ liệt kê trong hợp đồng để có thể tự động khóa hay mở khóa chúng.
- **Chữ kí điện tử** : Tất cả các bên tham gia vào Smart Contract đều phải đồng ý triển khai thỏa thuận bằng các khóa cá nhân (chữ kí điện tử) của họ.
- **Điều khoản hợp đồng** : Điều khoản trong Smart Contract có dạng là một chuỗi các hoạt động. Và các bên tham gia hợp đồng đều phải ký chấp nhận nó.
- \*_Nền tảng phần quyền_ : Smart Contract sau khi hoàn tất sẽ được tải lên Blockchain của nền tảng phân quyền tương ứng và được phân phối về cho các node của nền tảng ấy.

# Solidity

- Là ngôn ngữ lập trình cấp cao, hướng đối tượng được sử dụng để viết ra các Smart Contract dựa trên công nghệ Blockchain
- Smart Contract chạy trên máy ảo Ethereum (Ethereum Virtal Machine)
- Là một ngôn ngữ ngoặc nhọn, và Solidity bị ảnh hưởng nhiều bởi các ngôn ngữ lập trình như Python, C++ hay JavaScript
- Một số ứng dụng phổ biến của Solidity như là : Đấu giá sản phẩm, Bỏ phiếu, Huy động vốn, Tiền ảo,...
- EVM (Ethereum Virtal Machine) Là môi trường thời gian chạy các Smart Contract trong Ethereum
- Contract trong Solidity tương tự như class trong Java hay Python, có thể đa kế thừa sử dụng từ khóa 'is'
- Cấu trúc của một hàm trong Solidity : function function_name (parameter types) (internal | external | public | private) (pure | constant | view | payable) (returns (return types)) {}
  - *internal* : chỉ có thể truy cập từ các hàm bên trong Contract hoặc từ Contract con
  - *external* : có thể được truy cập từ Contract khác, bản thân Contract chứa hàm cũng có thể gọi nó thông qua 'this'
  - *public* : có thể được gọi từ Contract (không cần sử dụng đến this) hoặc từ contract khác
  - *private* : chỉ có thể truy cập từ hàm bên trong Contract
  - *pure* : không truy cậy hay thay đổi các thuộc tính của Contract
  - *view* : không thay đổi thuộc tính Contract
- variable trong solidity
  - state variables : các biến có giá trị được lưu trữ vĩnh viễn trong bộ lưu trữ Contract
  - local variables : biến cục bộ nằm ở bên trong function
  - global variables : là loại biến đặc biệt tồn tại trong không gian làm việc toàn cục và cung cấp thông tin về Blockchain và các thuộc tính giao dịch
- phạm vi variable trong solidity
  - *public* : có thể được truy cập nội bộ cũng như thông qua lời gọi. Hàm getter sẽ được tự động tạo
  - *internal* : chỉ có thể truy cập nội bộ từ Contract hoặc Contract bắt nguồn từ nó
  - *private* : chỉ truy cập nội bộ bên trong Contract
- kiểu dữ liệu : dựa trên kiểu dữ liệu của một biến, hệ điều hành phân bổ bộ nhớ và quyết định những gì có thể lưu trữ trong bộ nhớ dành riêng
  - *bool* -> true/false
  - *int* -> số nguyên
  - *uint* -> số nguyên dương
  - *address* -> địa chỉ của account
  - *mapping* -> là kiểu ánh xạ dạng key-value
  - *struct* -> kiểu cấu trúc được sử dụng để biểu diễn một bản ghi
  - *enum* -> chứa các giá trị được xác định trước
  - *array* -> mảng lưu trữ dữ liệu cùng kiểu, length (lấy độ dài mảng) push (thêm phần tử vào cuối mảng trả lại mảng mới)
- *modifier* trong solidity được sử dụng để kiểm tra điều kiện trước khi đoạn code bên trong phương thức được thực thi
- toán tử trong Solidity :
  - toán tử số học :
    -  +(phép cộng)
    -  -(phép trừ)
    -  *(phép nhân)
    -  /(phép chia)
    -  %(chia lấy phần dư)
    -  ++(tăng dần)
    -  --(giảm dần)
  - toán tử so sánh :
    -  ==(bằng bằng)
      Kiểm tra xem giá trị của hai toán hạng có bằng nhau hay không, nếu có thì điều kiện trở thành true
    - !=(không bằng)
      Kiểm tra xem giá trị của hai toán hạng có bằng nhau hay không, nếu các giá trị không bằng nhau thì điều kiện trở thành true.
    - Lớn hơn: >
      Kiểm tra xem giá trị của toán hạng bên trái có lớn hơn giá trị của toán hạng bên phải hay không, nếu có thì điều kiện trở thành true.
    - <(nhỏ hơn)
      Kiểm tra xem giá trị của toán hạng bên trái có nhỏ hơn giá trị của toán hạng bên phải hay không, nếu có thì điều kiện trở thành true.
    - Lớn hơn hoặc Bằng: >=
      Kiểm tra xem giá trị của toán hạng bên trái có lớn hơn hoặc bằng giá trị của toán hạng bên phải hay không, nếu có thì điều kiện trở thành true.
    - <= (Nhỏ hơn hoặc Bằng)
      Kiểm tra xem giá trị của toán hạng bên trái có nhỏ hơn hoặc bằng giá trị của toán hạng bên phải hay không, nếu có thì điều kiện trở thành true.
  - toán tử logic :
    - && (và)
      Nếu cả hai toán hạng đều khác 0, thì điều kiện trở thành true.
    - || (hoặc)
      Nếu bất kỳ toán hạng nào trong hai toán hạng khác 0, thì điều kiện trở thành true.
    - ! (Không)
      Đảo ngược trạng thái logic của toán hạng của nó. Nếu một điều kiện là đúng, thì toán tử logic NOT sẽ làm cho nó sai.
  - toán tử bitwise :
    - & (Bitwise AND)
      Nó thực hiện phép toán Boolean AND trên mỗi bit của các đối số nguyên của nó.
    - | (BitWise OR)
      Nó thực hiện phép toán Boolean OR trên mỗi bit của các đối số nguyên của nó.
    - ^ (Bitwise XOR)
      Nó thực hiện một phép toán OR độc quyền Boolean trên mỗi bit của các đối số nguyên của nó.
      OR độc quyền có nghĩa là toán hạng một là đúng hoặc toán hạng hai là đúng, nhưng không phải cả hai.
    - ~ (Bitwise Not)
      Nó là một toán tử một ngôi và hoạt động bằng cách đảo ngược tất cả các bit trong toán hạng.
    - << (Dịch chuyển sang trái)
      Nó di chuyển tất cả các bit trong toán hạng đầu tiên sang trái theo số vị trí được chỉ định trong toán hạng thứ hai. 
      Các bit mới được lấp đầy bởi các số không. Chuyển một giá trị sang trái một vị trí tương đương với nhân nó với 2, dịch chuyển hai vị trí tương đương với nhân 4
    -  (Chuyển sang phải): >> 
       Toán tử chuyển sang phải nhị phân. 
       Giá trị của toán hạng bên trái được di chuyển sang phải bằng số bit được chỉ định bởi toán hạng bên phải.
    -  (Sang phải với Zero): >>>
       Toán tử này cũng giống như toán tử >>, ngoại trừ việc các bit được chuyển sang bên trái luôn bằng không.
  - toán tử gán :
    - = (bằng)
      Gán giá trị từ toán hạng bên phải cho toán hạng bên trái
    - +=
      Nó thêm toán hạng bên phải vào toán hạng bên trái và gán kết quả cho toán hạng bên trái
    - -=
      Nó trừ toán hạng bên phải khỏi toán hạng bên trái và gán kết quả cho toán hạng bên trái.
    - *= 
      Nó nhân toán hạng bên phải với toán hạng bên trái và gán kết quả cho toán hạng bên trái.
    - /= 
      Nó chia toán hạng bên trái với toán hạng bên phải và gán kết quả cho toán hạng bên trái.
    - %= 
      Nó có mô đun sử dụng hai toán hạng và gán kết quả cho toán hạng bên trái.
    Lưu ý : Logic tương tự áp dụng cho các toán tử Bitwise nên chúng sẽ giống như << =, >> =, >> =, & =, | = và ^ =.
  - toán tử có điều kiện :
    - Toán tử điều kiện đầu tiên đánh giá một biểu thức cho một giá trị đúng hoặc sai và sau đó thực hiện một trong hai câu lệnh đã cho tùy thuộc vào kết quả của việc đánh giá.
      ? : (Conditional ) Nếu điều kiện là đúng? Sau đó giá trị X: Ngược lại giá trị Y
      
- vòng lặp :
    ```
    while (biểu thức) {
       Các câu lệnh sẽ được thực thi nếu biểu thức là true
    }
    ```
    ```
    do {
       Các câu lệnh được thực hiện;
    } while (biểu thức);
    ```
    - (Lưu ý: Vòng lặp do ... while cũng tương tự như vòng lặp while ngoại trừ việc kiểm tra điều kiện xảy ra ở phần cuối của vòng lặp. Điều này có nghĩa là vòng lặp sẽ luôn được thực hiện ít nhất một lần, ngay cả khi điều kiện sai .)    
    ```
    for (tạo vòng lặp; lệnh kiểm tra; lệnh lặp) {
      Các câu lệnh sẽ được thực thi nếu điều kiện kiểm tra là đúng
    }
    ```
    - (Lưu ý:Vòng lặp for là hình thức nhỏ gọn nhất của vòng lặp. Nó bao gồm ba phần quan trọng sau:
    - Khởi tạo vòng lặp nơi chúng tôi khởi tạo bộ đếm của mình thành giá trị bắt đầu. Câu lệnh khởi tạo được thực hiện trước khi bắt đầu vòng lặp.
    - Câu lệnh kiểm tra sẽ kiểm tra xem một điều kiện đã cho có đúng hay không. Nếu điều kiện là đúng, thì mã được đưa ra bên trong vòng lặp sẽ được thực thi, nếu không thì điều khiển sẽ ra khỏi vòng lặp.
    - Câu lệnh lặp trong đó bạn có thể tăng hoặc giảm bộ đếm của mình.
    - Bạn có thể đặt tất cả ba phần trong một dòng duy nhất được phân tách bằng dấu chấm phẩy.)
  - kiểm soát vòng lặp :
    - *break* : Câu lệnh break , được giới thiệu ngắn gọn với câu lệnh switch , được sử dụng để thoát khỏi một vòng lặp sớm, thoát ra khỏi các dấu ngoặc nhọn bao quanh.
    - *continue* : Câu lệnh continue yêu cầu trình thông dịch bắt đầu ngay lập tức lần lặp tiếp theo của vòng lặp và bỏ qua khối mã còn lại. Khi gặp câu lệnh continue , luồng chương trình chuyển đến biểu thức kiểm tra vòng lặp ngay lập tức và nếu điều kiện vẫn đúng, thì nó bắt đầu lặp tiếp theo, nếu không thì điều khiển sẽ ra khỏi vòng lặp.

- câu lệnh điều kiện :
  - *if* : Ở đây, một biểu thức Solidity được đánh giá. Nếu giá trị kết quả là true, (các) câu lệnh đã cho sẽ được thực thi. Nếu biểu thức sai, thì không câu lệnh nào không được thực thi. Hầu hết các trường hợp, bạn sẽ sử dụng các toán tử so sánh trong khi đưa ra quyết định.
      ```
      if(biểu thức) {                                                                                                                                                                     Các câu lệnh sẽ được thực thi nếu biểu thức là đúng
      }
      ```
  - *if-else* :Ở đây biểu thức Solidity được đánh giá. Nếu giá trị kết quả là true, (các) câu lệnh đã cho trong khối 'if' sẽ được thực thi. Nếu biểu thức sai, thì (các) câu lệnh đã cho trong khối khác sẽ được thực thi
      ```
      if (biểu thức) {
        Các câu lệnh sẽ được thực thi nếu biểu thức là true
      } else {
        Các câu lệnh sẽ được thực thi nếu biểu thức là false
      }
      ```
    
  - *if-else if* :Các câu lệnh được thực thi dựa trên điều kiện đúng, nếu không có điều kiện nào là đúng thì khối else được thực thi.
        ```
        if (biểu thức 1) {
          Các câu lệnh sẽ được thực thi nếu biểu thức 1 là true
        } else if (biểu thức 2) {
          Các câu lệnh sẽ được thực thi nếu biểu thức 2 là true
        } else if (biểu thức 3) {
          Các câu lệnh sẽ được thực thi nếu biểu thức 3 là true
        } else {
          Các câu lệnh sẽ được thực thi nếu không có biểu thức nào là đúng
        }
        ```

# Ví dụ đơn giản;

### Dùng smartcontract trong một phiên đấu giá.

```solidity
pragma solidity >= 0.7.0 <0.9.0;

contract SimpleAution{
    address payable public beneficiary;
    uint public auctionEndTime;
    uint public highestBid;
    address public highestBider;
    bool ended = false;

    mapping (address => uint) public pendingReturns;
    event highestBidIncrease(address bidder, uint amount);
    event auctionEnded (address winner, uint amount);

    constructor (uint _biddingTime, address payable _beneficiary){
        beneficiary = _beneficiary;
        auctionEndTime = block.timestamp + _biddingTime;
    }

    function bid () public payable {
        if (block.timestamp > auctionEndTime){
            revert("Phien dau gia ket thuc");
        }
        if (msg.value <= highestBid){
            revert("Gia cua ban thap hon gia cao nhat");
        }
        if (highestBid != 0){
            pendingReturns[highestBider] += highestBid;
        }
        highestBider = msg.sender;
        highestBid = msg.value;
        emit highestBidIncrease(msg.sender, msg.value);
    }

    function withdraw () public returns (bool){
        uint amount = pendingReturns[msg.sender];
        if (amount > 0) {
            pendingReturns[msg.sender] = 0;

            if (!payable (msg.sender).send(amount)){
                pendingReturns[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }

    function auctionEnd() public {
        if (ended){
            revert("Phien dau da co the ket thuc");
        }
        if (block.timestamp < auctionEndTime){
            revert("Phien dau gia chua ket thuc");
        }

        ended = true;
        emit auctionEnded (highestBider, highestBid);

        beneficiary.transfer(highestBid);
    }
}
```
## Thư viện Azure Blockchain Workbench
# Khái niệm Azure Blockchain Workbench:
- Azure Blockchain Workbench Preview là một tập hợp các dịch vụ và khả năng của Azure được thiết kế để giúp bạn tạo và triển khai các ứng dụng blockchain để chia sẻ quy trình kinh doanh và dữ liệu với các tổ chức khác. Azure Blockchain Workbench cung cấp giàn giáo cơ sở hạ tầng để xây dựng các ứng dụng Blockchain cho phép các nhà phát triển tập trung và việc tạo logic kinh doanh và hợp đồng thông minh. Nó cũng giúp tạo các ứng dụng Blockchain dễ dàng hơn bằng cách tích hợp 1 số dịch vụ và khả năng của Azure để giúp tự động hoá các nhiệm vụ phát triển chung.

*Kiến trúc Azure Blockchain Workbench:* Azure Blockchain Workbench Preview đơn giản hoá việc phát triển ứng dụng blockchain bằng cách cung cấp giải pháp sử dụng 1 số thành phần Azure. Blockchain Workbench có thể được triển khai bằng cách sử dụng một mẫu giải pháp trong Azure Marketplace. Mẫu cho pháp bạn chọn các mô-đun và thành phần để triển khai bao gồm ngăn xếp blockchain, loại ứng dụng khách và hỗ trợ tích hợp Iot. Sau khi được triển khai, Blockchain Workbench cung cấp quyền truy cập và ứng dụng web, ứng dụng iOS và ứng dụng Android.

*Mô hình kiến trúc Azure Blockchain Workbench*

![image](https://user-images.githubusercontent.com/75937525/138595717-2bfd7780-29fc-4396-a857-51422151b90f.png)

**Clients applications:**
-	Workbench cung cấp các ứng dụng khách được tạo tự động cho web và thiết bị di động (iOS, Android), có thể được sử dụng để xác thực, kiểm tra và xem các ứng dụng blockchain. Giao diện ứng dụng được tạo động dựa trên siêu dữ liệu hợp đồng thông minh và có thể phù hợp với mọi trường hợp sử dụng. Các ứng dụng khách cung cấp giao diện người dùng giao diện người dùng cho các ứng dụng blockchain hoàn chỉnh được tạo bởi Blockchain Workbench. Ứng dụng khách xác thực người dùng thông qua Azure Active Directory (Azure AD) và sau đó trình bày trải nghiệm người dùng phù hợp với bối cảnh kinh doanh của hợp đồng thông minh. Trải nghiệm người dùng cho phép các cá nhân được ủy quyền tạo ra các phiên bản hợp đồng thông minh mới và sau đó thể hiện khả năng thực hiện các loại giao dịch nhất định tại các điểm thích hợp trong quy trình kinh doanh mà hợp đồng thông minh đại diện.
-	Trong ứng dụng web, người dùng được ủy quyền có thể truy cập bảng điều khiển dành cho quản trị viên. Bảng điều khiển có sẵn cho người dùng trong nhóm Quản trị viên trong Azure AD và cung cấp quyền truy cập vào chức năng sau:
1.	Triển khai các hợp đồng thông minh do Microsoft cung cấp cho các tình huống phổ biến. Ví dụ, một kịch bản chuyển giao tài sản.
2.	Tải lên và triển khai các hợp đồng thông minh của riêng họ.
3.	Chỉ định một người dùng quyền truy cập vào hợp đồng thông minh trong bối cảnh của một vai trò cụ thể.

**Gateway service API:**
-	Blockchain Workbench bao gồm một dịch vụ API cổng dựa trên REST. Khi ghi vào một chuỗi khối, API sẽ tạo và gửi thông điệp đến một nhà môi giới sự kiện. Khi dữ liệu được API yêu cầu, các truy vấn sẽ được gửi đến cơ sở dữ liệu ngoài chuỗi. Cơ sở dữ liệu chứa một bản sao dữ liệu trên chuỗi và siêu dữ liệu cung cấp thông tin cấu hình và ngữ cảnh cho các hợp đồng thông minh được hỗ trợ. Các truy vấn trả về dữ liệu được yêu cầu từ bản sao ngoài chuỗi theo định dạng được thông báo bởi siêu dữ liệu cho hợp đồng.
-	Các nhà phát triển có thể truy cập API dịch vụ để cổng xây dựng hoặc tích hợp các giải pháp blockchain mà không cần dựa vào các ứng dụng máy khách Blockchain Workbench.

**Distributed ledger consumer:**
-	Distributed ledger technology(DLT) chứa siêu dữ liệu cho các giao dịch được ghi vào blockchain. Người tiêu dùng truy xuất các tin nhắn và đẩy dữ liệu đến trình tạo giao dịch, người ký và bộ định tuyến.

**Database consumer:**
-	Cơ sở dữ liệu của người tiêu dùng nhận thông báo từ Service Bus và đẩy dữ liệu vào cơ sở dữ liệu đính kèm, chẳng hạn như cơ sở dữ liệu trong cơ sở dữ liệu Azure SQL.

**Storage consumer:**
-	Người tiêu dùng lưu trữ tin nhắn từ Service Bus và đẩy dữ liệu vào một bộ nhớ đính kèm. 
VD: lưu trữ các tài liệu băm trong Azure Storage

**Transaction builder and signer:**
-	Nếu một tin nhắn từ tin nhắn của nhà môi giới nhắn đến cần được ghi vào blockchain, nó sẽ được xử lý bởi người tiêu dùng DLT. Người tiêu dùng DLT là một dịch vụ, lấy thông điệp chứa siêu dữ liệu cho một giao dịch mong muốn để thực hiện và sau đó gửi thông điệp đến người tạo và người ký giao dịch. Người xây dựng và người ký giao dịch tập hợp một giao dịch blockchain dựa trên dữ liệu và điểm đến blockchain mong muốn. Sau khi tập hợp, giao dịch được ký kết. Các khoá cá nhân được lưu trữ trong Azure Key Vault.
-	Blockchain Workbench truy xuất khoá cá nhân thích hợp từ key Vault và ký giao dịch bên ngoài Key Vault. Sau khi được ký, giao dịch được gửi đến bộ định tuyến giao dịch và sổ cái.

**DLT watcher:**
-	Một trình theo dõi công nghệ sổ cái phân tán(DLT) giám sát các sự kiện xảy ra trên chuỗi khối gắn với Blockchain Workbench. Sự kiện phản ánh thông tin liên quan đến cá nhận và hệ thống.
VD: việc tạo các phiên bản hợp đồng mới, thực hiện các giao dịch và thay đổi trạng thái. Các sự kiện được nắm bắt và gửi đến nhà môi giới thông điệp đi, vì vậy chúng có thể được tiêu thụ bởi người tiêu dùng hạ nguồn.

**Azure SQL Database:**
-	Cơ sở dữ liệu gắn liền với Blockchain Workbench lưu trữ các định nghĩa hợp đồng, siêu dữ liệu cấu hình và bản sao dữ liệu có thể truy cập SQL được lưu trữ trong blockchain. Dữ liệu này có thể dễ dàng được truy vấn, trực quan hoá hoặc phân tích bằng cách truy cập trực tiếp vào cơ sở dữ liệu. Các nhà phát triển và những người dùng khác có thể sử dụng cơ sở dữ liệu để báo cáo, phân tích hoặc các tích hợp tập trung vào dữ liệu khác.
-	Lưu trữ ngoài chuỗi này cung cấp khả năng cho các tổ chức doanh nghiệp truy vấn dữ liệu trong SQL thay vì trong sổ cái blockchain. Ngoài ra, bằng cách tiêu chuẩn hoá trên một lược đồ tiêu chuẩn không thể hiện được các ngăn xếp công nghệ blockchain, lưu trữ ngoài chuỗi cho phép sử dụng lại các báo cáo và các hiện vật khác trong các dự án, kịch bản và tổ chức.

**Azure Storage:**
-	Azure Storage được sử dụng để lưu trữ các hợp đồng và siêu dữ liệu được liên kết với các hợp đồng.
-	Từ đơn đặt hàng và vận đơn, đến hình ảnh được sử dụng trong tin tức và hình ảnh y tế, đến video bắt nguồn từ một chuỗi liên tục bao gồm camera và hình ảnh chuyển động chính, tài liệu đóng một vai trò trong nhiều tình huống tập trung vào blockchain. Các tài liệu không thích hợp để đặt trực tiếp trên blockchain.
-	Blockchain Workbench hỗ trợ khả năng thêm tài liệu hoặc nội dùng phương tiện khác với logic nghiệp vụ blockchain. Hàm băm của tài liệu hoặc nội dung phương tiện được lưu trữ trong blockchain và tài liệu hoặc nội dung phương tiện thực tế được lưu trữ trong Azure Storage. Thông tin giao dịch liên quan được chuyển đến nhà môi giới tin nhắn đến, đóng gói, ký tên và chuyển đến chuỗi khối. Quá trình này kích hoạt các sự kiện, được chia sẻ thông qua trình môi giới thông báo gửi đi. SQL DB sử dụng thông tin này và gửi nó đến DB để truy vấn sau. Các hệ thống hạ nguồn cũng có thể sử dụng các sự kiện này để hoạt động khi thích hợp.


